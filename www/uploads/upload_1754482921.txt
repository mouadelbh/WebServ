------geckoformboundary102e58a11bc3cd30e7a425eac6e35d7c
Content-Disposition: form-data; name="files"; filename="Server.cpp"
Content-Type: text/x-c++src

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mel-bouh <mel-bouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/24 13:50:04 by mel-bouh          #+#    #+#             */
/*   Updated: 2025/07/10 15:23:53 by mel-bouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/Server.hpp"

Server::Server() : socket_fd(-1), index(0) {}

Server::~Server() {
	for (struct pollfd fd : fds) {
		close(fd.fd);
	}
}

void	Server::initServer() {
	int opt = 1;

	socket_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (socket_fd < 0)
		std::cerr << "Error creating socket" << std::endl, exit(1);
	sockaddr_in addr;
	fds.push_back((struct pollfd){socket_fd, POLLIN | POLLERR | POLLHUP | POLLNVAL, 0});
	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.s_addr = INADDR_ANY;
	setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	if (bind(socket_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
		std::cerr << "Error binding socket" << std::endl, exit(1);
	if (listen(socket_fd, 100) < 0)
		std::cerr << "Error listening on socket" << std::endl, exit(1);
	std::cout << "Server initialized on port " << PORT << std::endl;
}

void	Server::AcceptConnection(std::unordered_map<int, Client> &clients) {
	int	client_fd;
	sockaddr_in client_addr;
	socklen_t client_len;

	std::cout << "Waiting for a new connection..." << std::endl;
	client_len = sizeof(client_addr);
	memset(&client_addr, 0, client_len);
	client_fd = accept(socket_fd, (struct sockaddr *)&client_addr, &client_len);
	if (client_fd < 0) {
		std::cerr << "Error accepting connection" << std::endl;
		return ;
	}
	fcntl(client_fd, F_SETFL, O_NONBLOCK);
	clients[client_fd] = Client(client_fd, client_addr, client_len);
	fds.push_back((struct pollfd){client_fd, POLLIN | POLLHUP | POLLERR | POLLNVAL, 0});
}

void	Server::runServer(std::unordered_map<int, Client> &clients) {
	bool client_kicked;
	while (run) {
		try {
			int res = poll(fds.data(), fds.size(), -1);

			if (res < 0 || run == false)
				break ;
			for (size_t i = 0; i < fds.size();) {
				std::cout << "Checking fd: " << fds[i].fd << std::endl;
				int current_fd = fds[i].fd;
				client_kicked = false;
				if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL)) {
					if (current_fd == socket_fd) {
						std::cerr << "SERVER SOCKET ERROR!" << std::endl;
						break;
					}
					else
						kickClient(clients, fds, &i, &client_kicked);
					continue;
				}

				if (current_fd == socket_fd) {
					if (fds[i].revents & POLLIN)
						this->AcceptConnection(clients);
					i++;
					continue;
				}
				if (!checkIdle(clients[current_fd])) {
					kickClient(clients, fds, &i, &client_kicked);
					continue;
				}
				if (fds[i].revents & POLLIN && clients[current_fd].state != WRITING)
					clients[current_fd].getRequest(fds, &i) ? (void)0 : kickClient(clients, fds, &i, &client_kicked);
				else if (fds[i].revents & POLLOUT && clients[current_fd].state == WRITING) {
					clients[current_fd].sendResponse(fds, &i) ? (void)0 : kickClient(clients, fds, &i, &client_kicked);
				}
				if (!client_kicked)
					i++;
			}
		}
		catch (const std::bad_alloc &e) {
			std::cerr << "Memory allocation failed: " << e.what() << std::endl;
		}
		catch (const std::exception &e) {
			std::cerr << "An error occurred: " << e.what() << std::endl;
		}
		catch (...) {
			std::cerr << "An unknown error occurred." << std::endl;
		}
	}
	close(socket_fd);
}

------geckoformboundary102e58a11bc3cd30e7a425eac6e35d7c
Content-Disposition: form-data; name="files"; filename="Request.cpp"
Content-Type: text/x-c++src

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Request.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mel-bouh <mel-bouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/24 16:07:51 by mel-bouh          #+#    #+#             */
/*   Updated: 2025/06/28 13:47:18 by mel-bouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/Client.hpp"

Request::Request() : status(0), autoIndex(0), body_length(0), chunk_size(0), body_type(NONE) {
	parse_state = REQUEST_LINE;
	chunk_state = SIZE;
}

Request::~Request() {
	clear();
}

std::string Request::toString() const {
	std::string request_line = method + " " + path + " " + version + "\r\n";
	std::string headers_str;
	for (const auto &header : headers) {
		headers_str += header.first + ": " + header.second + "\r\n";
	}
	return request_line + headers_str + "\r\n" + body;
}

bool	Request::getBodyInfo() {
	auto it_content = headers.find("Content-Length");
	auto it_chunked = headers.find("Transfer-Encoding");

	if (it_chunked != headers.end() && it_content != headers.end()) {
		status = 400; return false;
	}
	if (it_chunked != headers.end()) {
		if (it_chunked->second != "chunked") {
			status = 400; return false;
		}
		body_type = CHUNKED;
	} else if (it_content != headers.end()) {
		body_type = CONTENT;
		if (!isNumber(it_content->second)) {
			status = 400;
			return false;
		}
		body_length = std::stoi(it_content->second);
		if (body_length < 0) {
			status = 400;
			return false;
		} else if (body_length >= MAX_BODY_SIZE) {
			status = 413;
			return false;
		}
	} else
		body_type = NONE;

	if (body_type == NONE && (method == "POST" || method == "PUT")) {
		status = 411;
		return false;
	}
	if (body_type != NONE) {
		auto it_content_type = headers.find("Content-Type");
		if (it_content_type != headers.end()) {
			if (!isValidContentType(it_content_type->second)) {
				status = 415; // Unsupported Media Type
				return false;
			}
		}
		else {
			status = 400;
			return false;
		}
	}
	return true;
}

bool	Request::getChunkSize(const std::string& buffer) {
	size_t index = buffer.length();
	size_t stop = buffer.find(";", autoIndex);
	if (stop != std::string::npos)
		index = stop;
	for (int i = 0; i < static_cast<int>(index); i++) {
		if (!std::isxdigit(buffer[i])) {
			status = 400; // Invalid chunk size
			chunk_size = 0;
			return false;
		}
		chunk_size = chunk_size * 16 + (buffer[i] >= '0' && buffer[i] <= '9' ? buffer[i] - '0' : std::tolower(buffer[i]) - 'a' + 10);
	}
	if (chunk_size < 0) {
		status = 400; // Negative chunk size
		chunk_size = 0;
		return false;
	}
	if (chunk_size > MAX_CHUNK_SIZE) {
		status = 413; // Chunk size too large
		chunk_size = 0;
		return false;
	}
	return true;
}

bool	Request::parseChunkedBody(const std::string& buffer) {
	size_t size_end;
	while (autoIndex < (int)buffer.length()) {
		if (chunk_state == SIZE) {
			size_end = buffer.find("\r\n", autoIndex);
			if (size_end == std::string::npos) {
				return false; // Wait for more data
			}
			if (!getChunkSize(buffer.substr(autoIndex, size_end - autoIndex)))
				return false; // Error in chunk size
			autoIndex = size_end + 2;
			if (chunk_size == 0)
				chunk_state = CHUNK_DONE; // End of chunks
			else
				chunk_state = DATA;
		}
		if (chunk_state == DATA) {
			if (buffer.length() - autoIndex < chunk_size + 2) {
				return false; // Wait for more data
			}
			if (buffer.substr(autoIndex + chunk_size, 2) != "\r\n") {
				status = 400; // Invalid chunk data
				return false;
			}
			body += buffer.substr(autoIndex, chunk_size);
			autoIndex += chunk_size + 2; // Move past chunk data and CRLF
			chunk_state = SIZE;
			chunk_size = 0;
		}
		if (chunk_state == CHUNK_DONE) {
			return true;
		}
	}
	return false;
}

std::string	Request::getType() {
	if (endsWith(path, ".html")) return "text/html";
	if (endsWith(path, ".css")) return "text/css";
	if (endsWith(path, ".png")) return "image/png";
	if (endsWith(path, ".jpg") || endsWith(path, ".jpeg")) return "image/jpeg";
	if (endsWith(path, ".gif")) return "image/gif";
	if (endsWith(path, ".js")) return "application/javascript";
	if (autoIndex && isDirectory(path)) return "text/html";
	return "application/octet-stream";
}

bool	Request::pathIsValid(int index) {
	(void)index;
	if (open(path.c_str(), O_RDONLY) == -1)
		return false;
	return true;
}

void	Request::clear() {
	status = 0;
	autoIndex = 0;
	body_length = 0;
	parse_state = REQUEST_LINE;
	chunk_state = SIZE;
	chunk_size = 0;
	body_type = NONE;
	method.clear();
	path.clear();
	version.clear();
	headers.clear();
	body.clear();
}

------geckoformboundary102e58a11bc3cd30e7a425eac6e35d7c--
